[
["vectorization-apply-and-for-loops.html", "Chapter 2 Vectorization, *apply and for loops 2.1 Vectorization 2.2 Family of *apply functions 2.3 Creating dynamic documents with mapply", " Chapter 2 Vectorization, *apply and for loops This section will cover the basics of vectorizations, the *apply family of functions and for loops.  2.1 Vectorization Almost everything in R is a vector. A scalar is really a vector of length 1 and a data.frame is a collection of vectors. An nice feature of  is its vectorized capabilities. Vectorization indicates that a function operates on a whole vector of values at the same time and not just on a single value1. If you have have ever taken a basic linear algebra course, this concept will be familiar to you.  Take for example two vectors:  \\[ \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix} +  \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix} = \\begin{bmatrix} 2 \\\\ 4 \\\\ 6 \\end{bmatrix} \\]  The corresponding R code is given by: a &lt;- c(1,2,3) b &lt;- c(1,2,3) a+b ## [1] 2 4 6 Many of the base functions in R are already vectorized. Here are some common examples: # generate a sequence of numbers from 1 to 10 (a &lt;- 1:10) ##  [1]  1  2  3  4  5  6  7  8  9 10 # sum the numbers from 1 to 10 sum(a) ## [1] 55 # calculate sums of each column colSums(iris[, -5]) ## Sepal.Length  Sepal.Width Petal.Length  Petal.Width  ##        876.5        458.6        563.7        179.9  Exercise: What happens when you sum two vectors of different lengths?    2.2 Family of *apply functions  apply, lapply and sapply are some of the most commonly used class of functions in R *apply functions are not necessarily faster than loops, but can be easier to read (and vice cersa) apply is used when you need to perform an operation on every row or column of a matrix or data.frame lapply and sapply differ in the format of the output. The former returns a list while the ladder returns a vector There are other *apply functions such as tapply, vapply and mapply with similar functionality and purpose   2.2.1 Loops vs. Apply # Getting the row means of two columns # Generate data N &lt;- 10000 x1 &lt;- runif(N) x2 &lt;- runif(N) d &lt;- as.data.frame(cbind(x1, x2)) head(d) ##           x1        x2 ## 1 0.05737701 0.6981417 ## 2 0.38872652 0.5607380 ## 3 0.24303232 0.7795124 ## 4 0.90139764 0.1903174 ## 5 0.20297410 0.1139873 ## 6 0.60176972 0.8328472 # Loop: # create a vector to store the results in  rowMeanFor &lt;- vector(&quot;double&quot;, N)  for (i in seq_len(N)) {         rowMeanFor[[i]] &lt;- mean(c(d[i, 1], d[i, 2])) }  # Apply: rowMeanApply &lt;- apply(d, 1, mean)  # are the results equal all.equal(rowMeanFor,rowMeanApply) ## [1] TRUE   2.2.2 Descriptive Statistics using *apply data(women) # data structure str(women) ## &#39;data.frame&#39;:    15 obs. of  2 variables: ##  $ height: num  58 59 60 61 62 63 64 65 66 67 ... ##  $ weight: num  115 117 120 123 126 129 132 135 139 142 ... # calculate the mean for each column apply(women, 2, mean) ##   height   weight  ##  65.0000 136.7333 # apply &#39;fivenum&#39; function to each column vapply(women, fivenum, c(&quot;Min.&quot; = 0, &quot;1st Qu.&quot; = 0, &quot;Median&quot; = 0,                           &quot;3rd Qu.&quot; = 0, &quot;Max.&quot; = 0)) ##         height weight ## Min.      58.0  115.0 ## 1st Qu.   61.5  124.5 ## Median    65.0  135.0 ## 3rd Qu.   68.5  148.0 ## Max.      72.0  164.0   2.2.3 Creating new columns using sapply You can apply a user defined function to columns or the entire data frame: # the ouput of sapply is a vector # the &#39;s&#39; in sapply stands for &#39;simplified&#39; apply mtcars$gear2 &lt;- sapply(mtcars$gear,                         function(i) if (i==4) &quot;alot&quot; else &quot;some&quot;)  head(mtcars)[,c(&quot;gear&quot;,&quot;gear2&quot;)] ##                   gear gear2 ## Mazda RX4            4  alot ## Mazda RX4 Wag        4  alot ## Datsun 710           4  alot ## Hornet 4 Drive       3  some ## Hornet Sportabout    3  some ## Valiant              3  some   2.2.4 Applying functions to subsets using tapply # Fisher&#39;s famous dataset  data(iris) str(iris) ## &#39;data.frame&#39;:    150 obs. of  5 variables: ##  $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ##  $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ##  $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ##  $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ##  $ Species     : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... # mean sepal length by species  tapply(iris$Sepal.Length, iris$Species, mean) ##     setosa versicolor  virginica  ##      5.006      5.936      6.588   2.2.5 Nested for loops using mapply mapply is my favorite base R function and here are some reasons why:  Using mapply is equivalent to writing nested for loops except that it is 100% more human readable and less prone to errors It is an effective way of conducting simulations because it iterates of many arguments  Let’s say you want to generate random samples from a normal distribution with varying means and standard deviations. Of course the brute force way would be to write out the command once, copy paste as many times as you want, and then manually change the arguments for mean and sd in the rnorm function as so: v1 &lt;- rnorm(100, mean = 5, sd = 1) v2 &lt;- rnorm(100, mean = 10, sd = 5) v3 &lt;- rnorm(100, mean = -3, sd = 10) This isn’t too bad for three vectors. But what if you want to generate many more combinations of means and sds ? Furthermore, how can you keep track of the parameters you used? Now lets consider the mapply function: means &lt;- c(5,10,-3) ; sds &lt;- c(1,5,10)   # MoreArgs is a list of arguments that dont change randomNormals &lt;- mapply(rnorm, mean = means, sd = sds,                          MoreArgs = list(n = 100))  head(randomNormals) ##          [,1]      [,2]       [,3] ## [1,] 6.774612  7.959221  -8.758044 ## [2,] 5.370869 15.230391 -19.120174 ## [3,] 4.347676 19.489983  -5.291814 ## [4,] 4.515484  1.188272 -23.130287 ## [5,] 4.895882 15.289938  -2.121837 ## [6,] 3.863820 13.205816   8.429858 The following diagram (from r4ds) describes exactly what is going on in the above function call to mapply:  Advantages:  Result is automatically stored in a matrix The parameters are also saved in R objects so that they can be easily manipulated and/or recovered  Consider a more complex scenario where you want to consider many possible combinations of means and sds. We take advantage of the expand.grid function to create a data.frame of simulation parameters: simParams &lt;- expand.grid(means = 1:10,                          sds = 1:10)  randomNormals &lt;- mapply(rnorm, mean = simParams$means,                          sd = simParams$sds,                          MoreArgs = list(n = 100))  dim(randomNormals) ## [1] 100 100    2.3 Creating dynamic documents with mapply mapply together with the rmarkdown package (Allaire et al. 2016) can be very useful to create dynamic documents for exploratory analysis. We illustrate this using the Motor Trend Car Road Tests data which comes pre-loaded in R.  The data was extracted from the 1974 Motor Trend US magazine, and comprises fuel consumption and 10 aspects of automobile design and performance for 32 automobiles (1973–74 models).  Copy the code below in a file called mapplyRmarkdown.Rmd :  Copy the code below in a file called boxplotTemplate :    "]
]
